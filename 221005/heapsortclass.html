<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      function Heap(type = "min") {
        this.items = [];
        this.type = type;
      }

      Heap.prototype.swap = function (idx1, idx2) {
        const temp = this.items[idx1];
        this.items[idx1] = this.items[idx2];
        this.items[idx2] = temp;
      };

      Heap.prototype.getParentIndex = function (idx) {
        return parseInt((idx - 1) / 2);
      };

      Heap.prototype.getLeftChildIndex = function (idx) {
        return idx * 2 + 1;
      };

      Heap.prototype.getRightChildIndex = function (idx) {
        return idx * 2 + 2;
      };

      Heap.prototype.getType = function () {
        return this.type === "max" ? -1 : 1;
      };

      Heap.prototype.insert = function (item) {
        this.items.push(item);
        //빈배열에 원소추가
        let nowIdx = this.items.length - 1;
        //nowIdx를 heapArr길이에 -1빼서 정의
        while (true) {
          if (nowIdx < 1) return this.items.length;
          const parentIdx = this.getParentIndex(nowIdx);
          if (
            this.items[parentIdx] * this.getType() >
            this.items[nowIdx] * this.getType()
          ) {
            //최대값순으로
            // if (heapArr[parentIdx]*-1 > heapArr[nowIdx]*-1) {
            //최소값순으로 크면클수록 마이너스로 갔을때 더작아진다
            this.swap(parentIdx, nowIdx);
            nowIdx = parentIdx;
            //최소값
          } else {
            break;
          }
        }
        return this.items.length;
      };

      Heap.prototype.remove = function (item) {
        const temp = this.items.shift();
        this.items.unshift(this.items.pop());

        let nowIdx = 0;
        while (true) {
          const leftChild = this.getLeftChildIndex(nowIdx),
            rightChild = this.getRightChildIndex(nowIdx);
          if (
            this.items[nowIdx] * this.getType() >
              this.items[leftChild * this.getType()] ||
            this.items[nowIdx] * this.getType() >
              this.items[rightChild] * this.getType()
          ) {
            if (
              this.items[leftChild] * this.getType() >
              this.items[rightChild] * this.getType()
            ) {
              this.swap(nowIdx, rightChild);
              nowIdx = rightChild;
            } else {
              this.swap(nowIdx, leftChild);
              nowIdx = leftChild;
            }
          } else {
            break;
          }
        }
        return temp;
      };
      //비교하는곳에 -1곱해주면 최대힙으로뜬다

      let heap = new Heap("max");
      heap.insert(28);
      heap.insert(10);
      heap.insert(100);
      heap.insert(1);
      heap.insert(15);

      console.log(heap.items);
      console.log(heap.remove());
      console.log(heap.items);
    </script>
  </body>
</html>
